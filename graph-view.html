<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Mermaid-like Graph Visualizer</title>

<!-- 
Changes based on feedback:
- Ensure rounded corners on nodes: we now set `attr("rx", 10)` and `attr("ry", 10)` directly on the <rect>.
- Remove all panning and zooming constraints. The user can pan and zoom freely.
  - Just center on the graph once at the initial load.
  - Removed clampTransform and updateZoomConstraints logic.
  - No forced scale extent either.
- Highlight Sources previously recolored all nodes. Now:
  - We don't re-layout the graph or recreate it on highlight toggle.
  - Instead, we store incoming edge counts and only recolor nodes that have no inbound edges when highlight is on.
  - Toggling Highlight Sources calls a function to just update node colors, no re-simulation.
- The text should remain centered vertically and horizontally in the node (using dominant-baseline: middle; text-anchor: middle).
- Picked a nicer color scheme. Normal nodes teal (#4db6ac), sources blue (#64b5f6).
-->

<style>
  body {
    font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
    margin: 0;
    display: flex;
    flex-direction: column;
    height: 100vh;
    background: #f9f9f9;
    color: #333;
  }

  header {
    background: #f2f2f2;
    padding: 15px;
    display: flex;
    flex-direction: column;
    gap: 10px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
  }

  .controls {
    display: flex;
    gap: 15px;
    align-items: center;
    flex-wrap: wrap;
  }

  .controls span {
    font-size: 14px;
  }

  header textarea {
    width: 100%;
    height: 140px;
    box-sizing: border-box;
    font-family: monospace;
    padding: 8px;
    resize: vertical;
    border: 1px solid #ccc;
    border-radius: 4px;
    background: #fff;
  }

  header button {
    background: #1976d2;
    border: none;
    color: #fff;
    padding: 6px 12px;
    cursor: pointer;
    border-radius: 4px;
    font-size: 14px;
    transition: background 0.2s ease;
  }

  header button:hover {
    background: #1565c0;
  }

  header input[type="checkbox"] {
    transform: scale(1.1);
    cursor: pointer;
  }

  #graph-container {
    flex: 1 1 auto;
    position: relative;
    background: #fff;
    overflow: hidden;
  }

  .link {
    stroke: #757575;
    stroke-opacity: 0.8;
    stroke-width: 1.5px;
  }

  .node text {
    pointer-events: none;
    font-size: 13px;
    fill: #ffffff;
    font-weight: 500;
    text-anchor: middle;
    dominant-baseline: middle;
  }

  #tooltip {
    position: absolute;
    pointer-events: none;
    background: rgba(0,0,0,0.75);
    color: #fff;
    padding: 4px 6px;
    font-size: 12px;
    border-radius: 4px;
    visibility: hidden;
    font-family: sans-serif;
  }
</style>

</head>
<body>

<header>
  <div class="controls">
    <span>Paste Mermaid-like code below:</span>
  </div>
  <textarea id="mermaid-input">graph TD
A-->B
B-->C
C-->A
D-->A</textarea>

  <div class="controls">
    <label style="display:flex;align-items:center;gap:5px;">
      <input type="checkbox" id="dag-mode" />
      <span>DAG Mode</span>
    </label>
    <label style="display:flex;align-items:center;gap:5px;">
      <input type="checkbox" id="highlight-sources" />
      <span>Highlight Sources</span>
    </label>
    <button id="recenter-btn">Recenter</button>
  </div>
</header>

<div id="graph-container">
  <svg id="graph" width="100%" height="100%"></svg>
  <div id="tooltip"></div>
</div>

<script src="https://d3js.org/d3.v7.min.js"></script>
<script>
let firstLoad = true;

const container = d3.select("#graph-container");
const svg = d3.select("#graph");
const tooltip = d3.select("#tooltip");
const dagModeCheckbox = document.getElementById("dag-mode");
const highlightSourcesCheckbox = document.getElementById("highlight-sources");
const recenterButton = document.getElementById("recenter-btn");

let simulation, linkElements, nodeElements, nodeGroup;
let nodesData = [], linksData = [];
let incomingCount = {}; // store incoming edges count per node id

// Setup zoom and pan without constraints.
const zoom = d3.zoom()
    .on("zoom", event => {
      g.attr("transform", event.transform);
    });

const g = svg.append("g");

svg.call(zoom).on("dblclick.zoom", null);

const inputElement = document.getElementById("mermaid-input");
inputElement.addEventListener("input", () => {
  updateGraph();
});

// DAG mode toggling re-runs the layout to show layering
dagModeCheckbox.addEventListener("change", () => {
  updateGraph();
});

// Highlight Sources should only recolor existing nodes, no re-layout.
highlightSourcesCheckbox.addEventListener("change", () => {
  updateNodeColors();
});

// Recenter button (just recenters once)
recenterButton.addEventListener("click", () => {
  recenterGraph();
});

function updateGraph() {
  const input = inputElement.value;
  const {nodes, links} = parseMermaidInput(input);
  nodesData = nodes;
  linksData = links;
  console.log("Update Graph: parsed", {nodes, links});
  renderGraph(nodes, links, incomingCount);
}

function parseMermaidInput(input) {
  const lines = input.split("\n").map(l => l.trim()).filter(l => l.length > 0);
  let nodesSet = new Set();
  let edges = [];
  
  // Initialize incoming counts
  incomingCount = {};

  const edgePattern = /^(.+?)-->(?:\|([^|]+)\|)?(.+)$/;

  for (let line of lines) {
    if (line.startsWith("graph ") || line.startsWith("%%")) {
      continue;
    }
    const match = line.match(edgePattern);
    if (match) {
      let source = match[1].trim();
      let target = match[3].trim();
      nodesSet.add(source);
      nodesSet.add(target);
      edges.push({source, target});
      
      // Initialize counts for new nodes
      if (!incomingCount[source]) incomingCount[source] = 0;
      if (!incomingCount[target]) incomingCount[target] = 0;
      // Increment target's incoming count
      incomingCount[target]++;
    }
  }

  const nodes = Array.from(nodesSet).map(n => ({id: n}));
  console.log("Parsed incoming counts:", incomingCount); // Debug log
  return {nodes, links: edges};
}

function renderGraph(nodes, links, incomingCount) {
  console.log("Rendering graph with", nodes.length, "nodes and", links.length, "links");
  g.selectAll("*").remove();

  if (nodes.length === 0 && links.length === 0) {
    console.log("No nodes or links found. Nothing to render.");
    return;
  }

  // Compute DAG levels if DAG mode is on
  let dagLevels = {};
  if (dagModeCheckbox.checked) {
    dagLevels = computeLevels(nodes, links);
  }

  simulation = d3.forceSimulation(nodes)
    .force("link", d3.forceLink(links).id(d => d.id).distance(80))
    .force("charge", d3.forceManyBody().strength(-300))
    .force("center", d3.forceCenter(0,0))
    .force("collision", d3.forceCollide().radius(30));

  if (dagModeCheckbox.checked) {
    const levelForce = d3.forceY(d => (dagLevels[d.id] || 0)*120).strength(0.5);
    simulation.force("yLevel", levelForce);
    simulation.force("xCenter", d3.forceX(0).strength(0.05));
  } else {
    simulation.force("yLevel", null);
    simulation.force("xCenter", null);
  }

  simulation.on("tick", ticked).on("end", onSimulationEnd);


  // Define arrow marker
  const defs = g.append("defs");
  defs.selectAll("marker")
    .data(["arrow"])
    .join("marker")
    .attr("id", d => d)
    .attr("viewBox", "0 -5 10 10")
    .attr("refX", 22)
    .attr("refY", 0)
    .attr("markerWidth", 5)
    .attr("markerHeight", 5)
    .attr("orient", "auto")
    .attr("fill", "#757575")
    .append("path")
    .attr("d", "M0,-5L10,0L0,5");

  linkElements = g.append("g")
    .selectAll("line")
    .data(links)
    .join("line")
    .attr("class", "link")
    .attr("marker-end", "url(#arrow)");

  nodeGroup = g.append("g").selectAll("g")
    .data(nodes)
    .join("g")
    .attr("class", "node")
    .call(d3.drag()
          .on("start", dragstarted)
          .on("drag", dragged)
          .on("end", dragended));

  // Append text first
  nodeGroup.append("text")
    .text(d => d.id);

  // Measure text to size rectangle
  nodeGroup.each(function(d) {
    const textElem = d3.select(this).select("text").node();
    const bbox = textElem.getBBox();
    const paddingX = 12;
    const paddingY = 8;
    d.bboxWidth = bbox.width + paddingX*2;
    d.bboxHeight = bbox.height + paddingY*2;
  });

  // Add rectangle behind text
  nodeGroup.insert("rect", "text")
    .attr("width", d => d.bboxWidth)
    .attr("height", d => d.bboxHeight)
    .attr("x", d => -d.bboxWidth/2)
    .attr("y", d => -d.bboxHeight/2)
    .attr("rx", 10)
    .attr("ry", 10);

  nodeGroup.on("mouseover", (event,d) => {
    tooltip.style("visibility", "visible").text(d.id);
  }).on("mousemove", (event) => {
    const [x, y] = d3.pointer(event, container.node());
    tooltip.style("top", (y+20)+"px").style("left",(x+20)+"px");
  }).on("mouseout", () => {
    tooltip.style("visibility", "hidden");
  });

  nodeElements = nodeGroup;

  // After the nodes are created, set their colors according to highlight-sources
  updateNodeColors();

  function ticked() {
    linkElements
      .attr("x1", d => d.source.x)
      .attr("y1", d => d.source.y)
      .attr("x2", d => d.target.x)
      .attr("y2", d => d.target.y);

    nodeElements.attr("transform", d => `translate(${d.x},${d.y})`);
  }
}

function onSimulationEnd() {
  console.log("Simulation ended.");
  if (firstLoad) {
    // Just center on the graph once
    recenterGraph();
    firstLoad = false;
  }
}

function dragstarted(event, d) {
  if (!event.active) simulation.alphaTarget(0.3).restart();
  d.fx = d.x;
  d.fy = d.y;
}
function dragged(event, d) {
  d.fx = event.x;
  d.fy = event.y;
}
function dragended(event, d) {
  if (!event.active) simulation.alphaTarget(0);
  d.fx = null;
  d.fy = null;
}

function computeLevels(nodes, links) {
  const inDegree = {};
  const adj = {};
  nodes.forEach(n => {
    inDegree[n.id] = 0;
    adj[n.id] = [];
  });

  links.forEach(l => {
    inDegree[l.target]++;
    adj[l.source].push(l.target);
  });

  const queue = [];
  for (let n of nodes) {
    if (inDegree[n.id] === 0) queue.push(n.id);
  }

  const level = {};
  queue.forEach(n => level[n] = 0);

  while (queue.length > 0) {
    const curr = queue.shift();
    for (let nxt of adj[curr]) {
      if (level[curr] != null) {
        if (level[nxt] == null) level[nxt] = level[curr] + 1;
        else level[nxt] = Math.min(level[nxt], level[curr]+1);
      }
      inDegree[nxt]--;
      if (inDegree[nxt] === 0) {
        queue.push(nxt);
      }
    }
  }

  return level;
}

function recenterGraph() {
  const bbox = computeNodesBoundingBox(nodesData);
  const width = container.node().clientWidth;
  const height = container.node().clientHeight;
  const padding = 100;

  const xSize = (bbox.xMax - bbox.xMin) || 1;
  const ySize = (bbox.yMax - bbox.yMin) || 1;

  const fitScale = Math.min((width - padding) / xSize, (height - padding) / ySize);
  const centerX = (bbox.xMin + bbox.xMax)/2;
  const centerY = (bbox.yMin + bbox.yMax)/2;

  const transform = d3.zoomIdentity
    .translate(width/2, height/2)
    .scale(fitScale)
    .translate(-centerX, -centerY);

  svg.transition().duration(500).call(zoom.transform, transform);
}

function computeNodesBoundingBox(nodes) {
  if (!nodes || nodes.length === 0) {
    return {xMin:0, xMax:0, yMin:0, yMax:0};
  }

  let xMin = Infinity, xMax = -Infinity, yMin = Infinity, yMax = -Infinity;
  for (const d of nodes) {
    if (d.x < xMin) xMin = d.x;
    if (d.x > xMax) xMax = d.x;
    if (d.y < yMin) yMin = d.y;
    if (d.y > yMax) yMax = d.y;
  }

  return {xMin, xMax, yMin, yMax};
}

// Just recolor nodes based on highlight-sources checkbox
function updateNodeColors() {
  const highlightOn = highlightSourcesCheckbox.checked;
  console.log("Incoming counts:", incomingCount);
  console.log("Highlight sources enabled:", highlightOn);

  nodeElements.select("rect")
    .attr("fill", d => {
      console.log(`Node ${d.id} has ${incomingCount[d.id]} incoming edges`);
      if (highlightOn && incomingCount[d.id] === 0) {
        return "#000080"; // Source node color (dark blue)
      } else {
        return "#333333"; // Normal node color (dark gray)
      }
    });
}

// Initial render
updateGraph();
</script>

</body>
</html>
